---
title: "プログラム、下から作るか？上から作るか？"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Python"]
published: false
---

## TL;DL

* プログラムは「下から組む方法」と「上から組む方法」がある
* プログラムを組む時は少しずつテストしながら組む

## はじめに

なにかゼロからプログラムを組むとします。そのプログラムのアルゴリズムや、何をやるべきかはなんとなくわかっているけれど、どこから手をつけてよいかがわからず、ChatGPTに全部書かせて、その後修正できずに困る、という事例を何度か観測しています。

プログラムをゼロから書くのは慣れが必要です。プログラムをゼロから書く場合、小さな部品を一つ一つ作っていって、最後にそれらを組み上げる「下から書く」方法と、「こういう関数が必要であるはず」と外枠から書いていって最後に中身を埋める「上から書く」方法があります。その一般論を論じるのは私の能力を超えるため、以下では「下から」と「上から」の例を挙げて、その「気持ち」を説明してみようと思います。言語はなんでも良いですが、ここではPythonを使います。

## 下から書く例「パーコレーション」

### Union-Find

正方格子が与えられたとします。その格子のボンドが確率$p$で通行可能(アクティブ)、確率$1-p$で通行不能(インアクティブ)である時、この系の左辺から右辺まで、通行可能なボンドだけをたどって到達できる確率$P(p)$を求めなさい、というのがパーコレーション問題です。これは森林火災や病気の伝染などのモデルになっています。

各格子点をノードと呼び、それらに通し番号をつけ、アクティブなボンドで接続されたノードは同じクラスターであるとします。この時、「友達の友達は友達」と定義し、ノードAとBが同じクラスター、BとCが同じクラスターなら、AとCも同じクラスターであると定義します。ノードの集合と、アクティブなボンドでつながったノードペアの集合が与えられた時、任意の2つのノードが同じクラスターに属すかどうかを調べる手段を提供するのがUnion-Findアルゴリズムです。

Union-Findアルゴリズムは、2つのノードをつなげるunion関数と、あるノードのクラスター番号を返すfind関数の2つからなります。いくつか実装がありますが、一番簡単な一次元配列を使う実装にしましょう。では、コードを書き始めます。

### `main`関数の作成

最初にやることは、以下のように`main`関数を作ることです。

```py
def main():
    pass


if __name__ == "__main__":
    main()
```

`if __name__ == `はPythonのイディオムで、このスクリプトを直接実行した時のみ実行されるようにするものです(他のスクリプトからimportされた時は実行されない)。ここから`main`関数を呼び、あとはそこに処理を追加していきます。このように`main`関数を作る意味はグローバル変数を使わないようにするためです。グローバル変数はあとでバグの温床になります。プログラムの起点を関数にしておき、必要な変数を関数内で定義しておくと、「必要な変数は引数として渡す」という癖がつきます。

あとは、関数を追加しては、`main`関数にテストコードを書いて呼び出す、という手順を繰り返します。

### `find`関数の作成

最初に作るのは`find`関数です。自分の「親」をたどっていって、一番上に到達したらその番号を返す、というコードです。インデックス(`index`)と一次元配列(`cluter`)を受け取って、`while`を回すだけの簡単な関数です。こんな感じのコードになるでしょうか(わざと間違えています)。

```py
def find(index, cluster):
    while index != cluster[index]:
        index = cluster[index]
        return index
```

このコードを試してみましょう。テストコードを`main`に書きます。5つノードがあり、$i$番目のノードの親が$i-1$で、ノード番号$0$の親は自分自身、つまり、すべてのノードが同じクラスターに属している状態です。この状態で、それぞれのノードのクラスター番号を表示させます。

```py
def main():
    cluster = [0, 0, 1, 2, 3]
    for i in range(len(cluster)):
        print(i, find(i, cluster))
```

想定される出力は、すべてのクラスター番号が0と表示されるものです。しかし、実行してみるとこうなります。

```txt
0 None
1 0
2 1
3 2
4 3
```

想定出力と異なります。ここで`find`関数を見ると、`return`文のインデントを間違えていることに気づきます。直しましょう。

```py
def find(index, cluster):
    while index != cluster[index]:
        index = cluster[index]
    return index # ここのインデントがおかしかった。
```

もう一度実行します。

```txt
0 0
1 0
2 0
3 0
4 0
```

想定通りの出力になりました。まだコーナーケースのバグは残っているかもしれませんが、とりあえず`find`関数は完成です。こうやって、**一つ関数を書くたびに、必ず簡単なケースでテストします**。

## 上から書く例「LAMMPSの出力解析」


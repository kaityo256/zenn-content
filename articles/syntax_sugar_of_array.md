---
title: "C/C++の配列と糖衣構文"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["C","C++"]
published: false
---

## はじめに

関数の引数として多次元配列を受け取る時、以下の2つの違いを説明します。

```cpp
void func1(int a[2][3]) {
}

void func2(int (&a)[2][3]) {
}
```

## 配列とポインタと糖衣構文

度々話題になりますが、C/C++言語における`a[1]`のような配列表記は`*(a+1)`の糖衣構文となっています。

こんな配列宣言があったとします。

```cpp
  int a[] = {1, 2, 3};
```

この時、`a`はこの配列の先頭データへのポインタになります。したがって、アスタリスクをつけることで値を取り出すことができます。

```cpp
  printf("%d\n", *a);       // => 1
```

つまり、`*a`は`a[0]`と同じ意味です。さて、C/C++ではポインタに型が設定されています。ポインタに1を足すと、アドレスがその型のサイズだけずれます。ポインタが指すアドレスは`printf`の`%p`で表示できます。

```cpp
  printf("%p\n", a);     // => 0x7ffd794d272c
  printf("%p\n", a + 1); // => 0x7ffd794d2730
```

アドレス末尾に注目すると、`2c`から`30`、すなわち4バイトズレたことがわかります。なので、ポインタ`a+1`にアスタリスクをつけると、配列の2番目の要素にアクセスできます。

```cpp
  printf("%d\n", *(a + 1)); // => 2
```

つまり、`*(a + 1)`は`a[1]`と等価です。逆に`a[1]`と書くと、`*(a + 1)`と解釈され、前者は後者の糖衣構文になっています。

さて、`a[1]`が`*(a + 1)`になるのですから、`1[a]`は`*(1 + a)`と解釈されます。明らかに`a + 1`は`1 + a`と等しいので、`*(a + 1)`と`*(1 + a)`は同じ意味になります。以上から、`a[1]`と`1[a]`は同じ意味になります。なので、こんなコードも(気持ち悪いですが)全く合法です。

```cpp
  int a[] = {1, 2, 3};

  for (int i = 0; i < 3; i++) {
    // a[i]とi[a]は同じ意味になる
    printf("%d\n", i[a]); // => 1, 2, 3
  }
```

このあたりまではよく聞く話だと思います。

## 多次元配列

